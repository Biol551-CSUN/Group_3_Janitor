---
title: "function: get_dupes()"
author: "Marisa Mackie"
date: "`r Sys.Date()`"
output: html_document
---
## Function: get_dupes()

#### Introduction:
One issue that we sometimes run into when working with data is the presence of duplicate pieces of data, or "dupes".  This means that the **same information** is represented **more than once** in the same dataset.

Below is an example of data, with duplicates highlighted in red.

![example of duplicate data](https://yodalearning.com/wp-content/uploads/4.-DATA-WITH-DUPLICATE-RECORDS.png)

___________

#### How do dupes happen?
A few ways that duplicates can happen are via human error:

 * **User inputs data that is already there, i.e. they accidentally copy & pasted it twice**

 | Name | Number |
 |:----|---:|
 | CSUN | 1 |
 | CSUN | 1 |
 
 * **The user inputs the _same_ information in a _different way_**

| Name  | Number |
 |:-----|----:|
 | CSUN | 1 |
 | CSU Northridge | 1 |
 | Cal State University Northridge | 1 |
  
 * **Often these might be case sensitive**

 | Name | Number |
 |:----|---:|
 | csun | 1 |
 | Csun | 1 |
 | CSUN | 1 |
  
 * **Typos**

 | Name | Number |
 |:---------------|---:|
 | CSU Northridge | 1 |
 | CSU Notrhridge | 1 |
  
  
 | ID          | Number |
 |:------------|-------:|
 | 12200345000 | 1 |
 | 12200354000 | 1 |

________

#### What can I do about dupes?
The first step in dealing with dupes is to identify them.

The **Janitor** package has a useful function called **_get_dupes()_** that identifies & returns duplicates for you.

```{r setup, include = FALSE}

# load libraries
library(tidyverse)
library(here)
library(janitor)

```

To demonstrate this, let's load in the _fruits_with_dupes_ data.
```{r, message = FALSE}
# load data
fruits <- read_csv(here("Marisa","Data","fruits_with_dupes.csv"))

# look at first 10 lines
head(fruits,10)

```

Now let's ask Janitor to get duplicates for us!

You can input the data within the arguments of the function, or pipe to the function from the data.

```{r}
# Returns exact duplicates from your data
get_dupes(fruits)

```
You can also specify which columns you are looking for in the data, for example, fruit and rating.
```{r}
# Returns exact duplicates from your data
fruits %>% get_dupes(fruit, rating)
```


As you can see, Janitor returns all the duplicate values for us, and even includes a new column **dupe_count** to tell us _how many_ duplicate rows there are for each piece of data.

________

However, **_get_dupes()_** alone will only return **exact** duplicates of data. Misspellings or differences in user input wouldn't show up.

I have gone ahead and extracted the rows that contain _non-exact_ duplicates below so we can see them.

```{r, include = TRUE, echo = FALSE}
fruits_mispelled <- fruits[c(8, 11, 12, 16, 17, 24, 31, 34),]

head(fruits_mispelled, 8)
```

As you can see we have a few examples of non-exact duplicates here:

 * Misspellings - _"pomegranate"_ vs _"pomegranite"_
 
 * Variations (plural & singular) - _"banana"_ vs _"bananas"_
 

Since **_get_dupes_** returns only _exact duplicates_, we wouldn't be able to return non-exact duplicates without the help of other functions and/or packages.

_______
#### For advanced duplicate searches:
For a small & manageable list where we are familiar with all the data entries (like the fruits data), we may be able to find most of the duplicates using extra functions that can filter for similarly-spelled words.

However, if we had a very large data set with data entries that we were mostly unfamiliar with, we would have no way of knowing if we managed to find every single possible misspelling/variation of a word, and it would be very difficult to find these types of duplicates without some techniques that are far more advanced than our current level of coding, and beyond the scope of this class.


