---
title: 'Function: get_one_to_one()'
author: "Lipi"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = TRUE,
	warning = FALSE
)
```

# Data cleaning and manipulation using Janitor package in R

It is important to organize and clean the data.frame for clear comparison and better understanding of the data. 

Janitor package in R consists of different functions that can be used to clean and organize the data.frame.

# **Function 1: clean_names()**

When we have data.frames with problematic variable names, we can use the function clean_names() to get a clean data.frame.

# How does the function **clean_names()** work?

1. Parses letter cases and separators to a consistent format. (Ex. *first_Name* to **first_name**)

"snake_case" is the default case used by R in which all the letters are in lowercase and separated by an underscore if there are more than one words in the name. 

For snake_case: "snake"

You can input **??snakecase::to_any_case** in the console to see what other types of cases are available that you can use if required. 

- lowerCamel: "lower_camel" or "small_camel"

- UpperCamel: "upper_camel" or "big_camel"

- ALL_CAPS: "all_caps" or "screaming_snake"

- lowerUPPER: "lower_upper"

- UPPERlower: "upper_lower"

- Sentence case: "sentence"


2. Handles special characters and spaces (Ex. *age?!* to **age**)

3. Converts “%” to “percent” and “#” to “number” to retain meaning (Ex. *sleep %* to **sleep_percent**)

4. Appends numbers to duplicated names (Ex. if there are two columns with same name, *city*, one of them will be converted to **city** and other to **city_2**)

5. Retains numerical values the way they are and separates them from words by an underscore (Ex. *birth date (2000)* to **birth_date_2000**)

## Let's code to see how it works!

**First, load the libraries**

```{r}
library(tidyverse)
library(here)
library(tidyr)
library(dplyr)
library(janitor)
library(palmerpenguins)
```


**Now let's create a dirty data.frame, *df_1* **

```{r}
df_1 <- as.data.frame(matrix(ncol = 6)) # creates a new data.frame named df_1 which has 6 columns
names(df_1) <- c("firstName", "age?!", "sleep %",
                    "city", "city", "birth date (2000)") # gives names to each of the 6 columns in order of the input
View(df_1) # opens df_1

```

# Awesome!

**Finally, use the function *clean_names()* to get a data.frame with clean names**

All you have to do is **pipe (%>%)** it to your data.frame and run it.

```{r}
df_1 %>%
  clean_names()
```


# **Function 2: get_one_to_one()**

# How does the function **get_one_to_one()** work?

This function shows which, if any, columns in a data.frame have one-to-one relationships with each other.

We don't have to load any extra libraries for this function. So, let's move on to **loading the data.**
 
```{r echo=TRUE}
# Read and View the data

drugs <- read_csv(here("Lipi","Data","drugs.csv"))
glimpse(drugs)
View(drugs)
```

**Now let's call *get_one_to_one()* function to show us 1:1 relationship between different columns**

One liner code for this function is to call the function and enter the rows and columns of which you want to explore the relationship:

**Format: get_one_to_one(data[a,b])**

- **data** = data.frame of your choice
- **a** = rows (eg. for first 5 rows, enter 1:5)
- **b** = columns (eg. for first 6 columns, enter 1:6)
- If you leave a and/or b blank, it will consider the default value which is all the rows and columns of the data


**Example 1: First 5 rows and all the columns of data.frame [a=1:5 and b=blank]**

```{r echo=TRUE}
get_one_to_one(drugs[1:5,]) # shows relation between first 5 rows and all the columns
```

Output shows us variables (columns) grouped by three sets of 1:1 clusters. 
If you change 1:5 to 3:5, it will give you the same result because it is basically comparing the columns and not the rows.


**Example 2: All the rows and first 5 columns of data.frame [a=blank and b=1:5]**

```{r}
get_one_to_one(drugs[,1:5]) # shows relation between all the rows and first 5 columns
```

No output :(
This means we must enter a *specific value for "rows, a"*.


**Example 3: First 5 rows and first 5 columns of data.frame [a=1:5 and b=1:5]**

```{r}
get_one_to_one(drugs[1:5,1:5]) # shows relation between first 5 rows and first 5 columns
```

Output shows one set grouped by 1:1 cluster.


**Example 4: All the rows and all the columns of data.frame [a=blank and b=blank]**

```{r}
get_one_to_one(drugs[,]) # shows relation between all the rows and all the columns
```

No output :(
This means we need to tell R the **specific rows (a) and columns (b)** between which we want to explore 1:1 relationship.


# Think, Pair and Share 

Use different data (ex. penguins data) to explore get_one_to_one() function. 

```{r}
get_one_to_one(penguins[4:6,])
```

